- hosts: localhost
  gather_facts: no
  vars_files:
    - variables/vars.yml
    - variables/encrypt-iam-account.yml
  tasks:
    - name: provision CentOS VM (EC2) *****
      ec2:
        aws_access_key: "{{ ec2_access_key }}"
        aws_secret_key: "{{ ec2_secret_key }}" 
        ec2_region: "{{ AWS_REGION }}"
        instance_type: "{{ INSTANCE_TYPE }}"
        keypair: "{{ KEYPAIR }}"
        image: "{{ IMAGE }}"
        assign_public_ip: yes
        vpc_subnet_id: "{{ VPC_SUBNET_ID }}"
        group_id: "{{ GROUP_ID }}"
        wait: true
        exact_count: "{{ EXACT_COUNT }}"    
        count_tag: 
          Name: Demo
        instance_tags:
          Name: "{{ INSTANCE_TAGS }}"
      register: ec2
    - debug:
        var: ec2

    - name: Create volume *****
      ec2_vol:
        instance: "{{ item.id }}"
        aws_access_key: "{{ ec2_access_key }}"
        aws_secret_key: "{{ ec2_secret_key }}" 
        name: volume for "{{ item.id }}"
        region: "{{ AWS_REGION }}"
        device_name: "{{ DEVICE_NAME }}"
        volume_size: "{{ VOLUME_SIZE }}"
        volume_type: "{{ VOLUME_TYPE }}"
        encrypted: true
        delete_on_termination: true
      loop: "{{ ec2.instances }}"
      register: ec2_vol
    - debug:
        var: ec2_vol


    - name: Add hosts to inventory  *****
      add_host:
        hostname: '{{ item.public_ip }}'
        groupname: demogroup  # after this section is run, then we have the IPs in "demogroup"
        ansible_ssh_common_args: "-o StrictHostKeyChecking=no" # we attach a variable to "demogroup", We don't want to confirm the key validation
        ansible_ssh_private_key_file: keypair-for-ansible.pem
      loop: '{{ ec2.instances }}'
    
      
- hosts: demogroup
  gather_facts: no  # if this is "yes" , then a SSH will no be waiting for long.
  remote_user: centos
  tasks:
    - name: wait for SSH *****
      wait_for_connection:
        delay: 2
        timeout: 200

    - ec2_metadata_facts:   # ansible fetches EC2 facts from metadata for other variables.

    - name: debug *** ansible_ec2_local_ipv4 ***
      debug: var=ansible_ec2_local_ipv4

    - name: debug *** ansible_ec2_public_ipv4 ***
      debug: var=ansible_ec2_public_ipv4

    - name: debug *** ansible_ec2_public_hostname ***
      debug: var=ansible_ec2_public_hostname


    - name: Mount volume (EBS) to VM (EC2)  *****
      command: "{{ item }}"
      with_items:
        - file -s /dev/xvdb
        - mkfs -t ext4 /dev/xvdb
        - mkdir /newStorage
        - mount /dev/xvdb /newStorage/
      become: true
  

    - name: Check the size of volumes
      command: df -h
      register: check
    - debug:
        var: check

    - name: Check the OS
      command: hostnamectl
      register: check
    - debug:
        var: check
      

    - name: Update CentOS, install Docker and others *****
      command: "{{ item }}"
      with_items:
        - yum update -y
        - dnf install python3 -y
        - pip3 install pexpect
        - dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo  # enable Docker CE repository
        - dnf repolist -v # verify repository
        - dnf install docker-ce --nobest -y
        # - dnf install docker-ce docker-ce-cli containerd.io -y  # install Docker 
        - dnf install curl -y  # This will install Docker Compose
        - curl -L "https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        - chmod +x /usr/local/bin/docker-compose
      become: true


    - name: Start Docker's services *****
      command: "{{ item }}"
      with_items:
        - systemctl daemon-reload
        - systemctl start docker
        - systemctl enable docker
      become: true


    - name: check if Docker is being run
      command: systemctl status docker
      register: docker_check
      ignore_errors: yes
      become: true
    - debug:
        var: docker_check

    
    # - name: install pexpect ***** # if we want to execute linux command, we need to install PEXPECT
    #   pip:
    #     name: pexpect
    #   become: yes


  ####################################################################
  #                                                                  #
  #    Protect the Docker daemon to be secure                        #
  #                                                                  #
  #    According to https://docs.docker.com/engine/security/https/   #
  #                                                                  # 
  ####################################################################

    - name: Generate the Private Key *******
      expect:
        command: openssl genrsa -aes256 -out ca-key.pem 4096
        responses:
          'Enter': "12345"
          'Verifying': "12345"
      no_log: false # don't want to show passwords in logs
  

    - name: Generate the Public Key *******
      expect:
        command: openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem
        responses:
          'Enter pass phrase for ca-key.pem': "12345"
          'Country Name': "th"
          'State or Province Name': "Bangkok"
          'Locality Name': "Sukhumwit"
          'Organization Name': "Kixxxx"
          'Organizational Unit Name': "DevTeam"
          'Common Name': "{{ ansible_ec2_public_hostname }}"
          'Email Address': "sample@kixxxx.com"
      no_log: false

    
    - name: Create a server key and certificate signing request (CSR) *****
      command: "{{ item }}"
      with_items:
        - openssl genrsa -out server-key.pem 4096
        - openssl req -subj "/CN={{ ansible_ec2_public_hostname }}" -sha256 -new -key server-key.pem -out server.csr
      become: true


    - name: Sign the public key with our CA  (1) *** #  to allow connections 
      shell: echo "subjectAltName = DNS:{{ ansible_ec2_public_hostname }},IP:{{ ansible_ec2_public_ipv4 }},IP:{{ ansible_ec2_local_ipv4 }}" > extfile.cnf
      args:
        creates: "extfile.cnf"
  
    - name: Sign the public key with our CA  (2) *** # Set the Docker daemon keyâ€™s extended usage attributes to be used only for server authentication:
      shell: echo "extendedKeyUsage = serverAuth" > extfile.cnf
 


    - name: Generate the signed certificate *******
      expect:
        command: openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf
        responses:
          'Enter': "12345"
      no_log: false # don't want to show passwords in logs


    - name: Create a client key and certificate signing request (For client authentication) *****
      command: "{{ item }}"
      with_items:
        - openssl genrsa -out key.pem 4096
        - openssl req -subj '/CN=client' -new -key key.pem -out client.csr
      become: true


    - name: Create a new extensions config file (To make the key suitable for client authentication) ***
      shell: echo "extendedKeyUsage = clientAuth" > extfile-client.cnf


    - name: Generate the signed certificate *******
      expect:
        command: openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnf
        responses:
          'Enter': "12345"
      no_log: false
    

    - name: Remove some file and change permission to others ***** #After generating cert.pem and server-cert.pem , we can safely remove the two certificate signing requests and extensions config files
      command: "{{ item }}"
      with_items:
        - rm -v client.csr server.csr extfile.cnf extfile-client.cnf
        - chmod -v 0400 ca-key.pem key.pem server-key.pem
        - chmod -v 0444 ca.pem server-cert.pem cert.pem
      become: true
  

    # - name: Make the Docker daemon only accept connections from clients providing a certificate trusted by your CA *****
    #   command: dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem -H=0.0.0.0:2376
    #   become: true
    #   register: mycmd
    # - debug:
    #     var: mycmd 


    # - name: i ***** 
    #   command: "{{ item }}"
    #   with_items:
        # - systemctl stop docker
        # - rm -rf /var/lib/docker
        # - systemctl start docker
        # - ps axf | grep docker | grep -v grep | awk '{print "kill -9 " $1}' | sudo sh
        # - rm /var/run/docker.pid
        # - dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem -H=0.0.0.0:2376  
      # become: true
